#!/usr/bin/perl

# Password Manager - (C) WebCentral Pty Ltd 

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

# PERL DOC #################################################################

=head1 NAME

B<passmg> - A utility for managing and accessing stored passwords.

=head1 SYNOPSIS

passmg [-h|-v [-d|-D] [-H <int>]

passmg --create-user <username>

passmg --delete-user <username>

passmg --show-user <username>

passmg --create-group <group> [user1][,user2]...

passmg --show-group <group>

passmg --delete-group <group>

passmg --add-grp-access <group> <user1>[,user2]...

passmg --rem-grp-access <group> <user1>[,user2]...

passmg --create-key <key> \
	[-]<user1|@group1>[,[-]<user2|@group2>]...

passmg --delete-key <key>

passmg --change-key <key>

passmg --show-key <key>

passmg --add-key-access <key> \
	<[-]<user1|@group1>[,[-]<user2|@group2>]...

passmg --rem-key-access <key> \
	<user1|@group1>[,<user2|@group2>]...

passmg --list-users <regex>

passmg --list-groups <regex>

passmg --list-keys <regex>

passwd --change-pass [user]

=head1 DESCRIPTION

B<passmg> is a suid perl script designed to lessen the problems of shared/common passwords amongst administators.  Although having passwords being used by multiple individuals is itself a risk, especially when auditing actions performed using that password, it is often an inescapable nessessity.  This problem is further aggrevated by a tendency to change shared passwords very infrequently due largly to the difficulties involved in diseminating the new passwords to all parties in a way that does not itself further compromise it.  

B<passmg> addresses this problem by keeping a central repository of passwords stored in PGP encrypted files.  Each user who has been granted access to the repository has their own PGP public and private key pair.  Each password file is encrypted using all the appropriate public keys meaning each user can access the respository using their own pass phrase.  Access control is determined username and group membership on a per key basis.

When granting or revoking access for a user the master key (root) is used to decrypt and reencrypt all the password files.  This master key is not acutally special in anyway except being associated with the root user.  

=head1 MYSQL SCHEMA

B<passmg> relies on mysql as backend store for both the keys and the tables
containing the list of users and group and associated access controls.

CREATE DATABASE passmg;

CREATE USER 'passmg'@'localhost' IDENTIFIED by '$PASSWD';

GRANT SELECT, INSERT, UPDATE, DELETE on passmg.* TO 'passmg';

USE passmg;

CREATE TABLE users (
        name VARCHAR(64) NOT NULL,
        secret BLOB NOT NULL,
        public BLOB NOT NULL,
        updated TIMESTAMP NOT NULL,
        UNIQUE (name)
        );

CREATE TABLE groups (
        name VARCHAR(64) NOT NULL,
        UNIQUE (name)
        );

CREATE TABLE ascs (
        name VARCHAR(64) NOT NULL,
        pass BLOB NOT NULL,
        updated TIMESTAMP NOT NULL
        );

CREATE UNIQUE INDEX ascs_index ON ascs (
        name, updated);

CREATE TABLE grpmbrs (
        name VARCHAR(64) NOT NULL,
        member VARCHAR(64) NOT NULL
        );

CREATE UNIQUE INDEX grpmbrs_index ON grpmbrs (
        name, member );

CREATE TABLE ascmbrs (
        name VARCHAR(64) NOT NULL,
        member VARCHAR(64) NOT NULL,
        flag CHAR(1) NOT NULL DEFAULT '+'
        );

CREATE UNIQUE INDEX ascmbrs_index ON ascmbrs (
       name, member
       );

=head1 ISSUES

B<passmg> has to run as suid in order to read the mysql password from a secure
config but perl no longer supports suid scripts

When changing a user's password or acccess, only the latest version of a key is
updated so they do not have access to the key history.  If the owner key is
change it could be possible to lose all access to old versions of the key. This
is a trade off to limit the number of items that need to be re-encrypted.

When a key is re-encrypted because of a user change rather than a key change, a
new key is saved as if it were a key change adding non-changes to the key
history.  This is safer, but noisy.

=head1 SEE ALSO

gpg(1)

=head1 VERSION

2.24

=head1 AUTHOR

Matthew Melvin

=cut

# GLOBALS ##################################################################

use strict;

use Getopt::Long;
use File::Basename;
use English;
use DBI;
use POSIX;
use Sys::Syslog;
use File::Temp qw/ tempdir /;
use Data::Dumper;
use Digest::MD5 qw/ md5_hex /;
use MIME::Base64;

use vars qw/ $VER $ARGV0 $DEBUG $TERM $RUID $RGID /;
use vars qw/ $DBHOST $DBNAME $DBUSER $DBPASS $DBHAND /;
use vars qw/ $CFGFILE $TEMPDIR $OWNER $HIST /;
use vars qw/ $TTYFLAGS $TERMIOS $MAXRATE /;

$TERM = $ENV{'TERM'};
$RUID = $ENV{'SUDO_UID'};
$RGID = $ENV{'SUDO_GID'};

%ENV = ();
$ENV{'PATH'} = "/usr/bin:/bin";
$ENV{'TERM'} = $TERM;

sub main ();
sub bail ($);
sub show_help ();
sub putlog ($$);
sub connect_db($$$$);
sub get_passwd ($$);
sub read_config ($);
sub check_keys ($);
sub delete_keys ($);
sub fetch_keys ($);
sub save_keys ($);
sub create_keys ($);
sub check_auth ($$);
sub show_user ($);
sub list_users ($);
sub check_group ($);
sub create_group ($);
sub add_to_group ($$);
sub rem_from_group ($$);
sub delete_group ($);
sub show_group ($);
sub list_groups ($);
sub add_to_asc ($$);
sub rem_from_asc ($$);
sub show_key ($);
sub check_asc ($);
sub encrypt_asc ($$$$);
sub decrypt_asc ($$$);
sub import_keys ($);
sub fetch_asc ($$);
sub get_updates ($$);
sub check_rate($);
sub save_asc ($);
sub delete_asc ($);
sub list_keys ($);
sub get_user_access ($);
sub get_group_mbrs ($);
sub get_group_access ($);
sub get_group_denies ($);
sub cleanup_user ($);
sub cleanup_group ($);
sub change_key ($);
sub read_passfile($);
sub save_passfile($$);

$VER = "2.24";

$ARGV0 = basename($0);
$ARGV0 =~ /(.+)/;
$ARGV0 = $1;

$DBHOST = 'localhost';
$DBNAME = 'passmg';
$DBUSER = 'passmg';
$DBPASS = 'XXXXXXXXXXXX';
$DBHAND = undef;

$CFGFILE = undef;
foreach ( "/etc", "/usr/local/etc/") {
	next unless ( -f "$_/passmg.cfg");
	$CFGFILE = "$_/passmg.cfg";
	last;
}

$OWNER = 0;

$MAXRATE = "3:3600";

$TERMIOS = undef;
$TTYFLAGS = undef;

main();

die "Unreachable code reached";

# MAIN BODY ################################################################

sub main () {
	my(%opts, $tty, $args);
	my($pass, $user, $file);
	my($buf, $ret, $mod, $grp, @out, $upd);
	my(%before, %after, %encrypt, $owner);

	# save arguments before getops works on them
	$args = join(" ", $0, @ARGV);
	$args =~ /(.+)/;
	$args = $1;

	Getopt::Long::Configure ("bundling");
	unless (Getopt::Long::GetOptions(
		"v|version" =>\$opts{'v'},
		"h|help" => \$opts{'h'},
		"d|debug" => \$opts{'d'},
		"D|no-debug" => \$opts{'D'},
		"c|config:s" => \$opts{'c'},
		"H|history:i" => \$opts{'H'},
		"initialise" => \$opts{'initialise'},
		"create-user:s" => \$opts{'create-user'},
		"delete-user:s"=> \$opts{'delete-user'},
		"show-user:s" => \$opts{'show-user'},
		"list-users" => \$opts{'list-users'},
		"create-group:s" => \$opts{'create-group'},
		"delete-group:s" => \$opts{'delete-group'},
		"show-group:s" => \$opts{'show-group'},
		"list-groups" => \$opts{'list-groups'},
		"add-grp-access:s" => \$opts{'add-grp-access'},
		"rem-grp-access:s" => \$opts{'rem-grp-access'},
		"a|create-key:s" => \$opts{'create-key'},
		"delete-key:s" => \$opts{'delete-key'},
		"change-key:s" => \$opts{'change-key'},
		"l|list-keys" => \$opts{'list-keys'},
		"show-key:s" => \$opts{'show-key'},
		"add-key-access:s" => \$opts{'add-key-access'},
		"rem-key-access:s" => \$opts{'rem-key-access'},
		"change-pass" => \$opts{'change-pass'},
		"f|from-file:s" => \$opts{'f'},
		"F|to-file:s" => \$opts{'F'},
	)) {
		show_help();
		bail(1);
	}

        unless ($tty = ttyname(fileno(0))) {
		$ret = $!;
                putlog('warning', "Called from non-tty device: $ret");
		$tty = "notty";
        }

	# are running under sudo or suid?
	if (($UID < 1) && ($EUID == $UID)) {
		$UID = defined $RUID ? $RUID : $UID;
		$GID = defined $RGID ? $RGID : $GID;
	}

	if ($EUID == $UID) {
       		$OWNER = 1;
		$user = 'root';
	} else {
		$OWNER = 0;
		$user = getpwuid($UID);
	}

        putlog('debug', "Started as " . scalar getpwuid($EUID) ."($EUID) for " . scalar getpwuid($UID) . "($UID) on $tty");
        putlog('notice', "Called by " . scalar getpwuid($UID) . " as: $args");

	if ($opts{'c'}) {
		# drop prives before reading user specified config file
		($EUID, $EGID) = ($UID, $GID);
		unless (($EUID == $UID) && ($EGID == $GID)) {
			$ret = $!;
			putlog('debug', "Dropping privleges before config read failed: $EUID/$EGID <=> $UID/$GID: $ret");
			print STDERR "Fatal: dropping elevated privledges failed: $ret\n";
			bail(1);
		}
		putlog('debug', "Dropping privledges to read user config: " . getpwuid($EUID) . "/" . getgrgid($EGID));
		$CFGFILE = $opts{'c'};
		$CFGFILE =~ /(.+)/;
		$CFGFILE = $1;
	}

	$owner = $OWNER;
	unless (read_config($CFGFILE)) {
		print STDERR "Fatal: unable to load the config file.\n";
		bail(1);
	}
	$OWNER = $owner;  # don't let owner by set in the config

	if (($opts{'D'}) && ($opts{'d'})) {
		print STDERR "Conflicting debug options provided.  Both -D and -d specified.\n";
        	show_help();
                bail(1);
        }
        $DEBUG = 1 if ($opts{'d'});
        $DEBUG = 0 if ($opts{'D'});

	if ($opts{'h'}) {
		show_help();
		bail(0);
	}

	if ($opts{'v'}) {
		print STDOUT "$ARGV0 version $VER\n";
		bail(0);
	}

        if (defined($opts{'H'})) {
                unless (($opts{'H'} > 0) && ($opts{'H'} =~ /^(\d+)$/)) {
                        print STDERR "Error: invalid history option specified.\n";
                        show_help();
                        bail(1);
                }
                $HIST = $1;
        }

	$HIST = 1 if ($HIST < 1);

	# only one long option allowed at a time
	if ((scalar grep { /../ && defined($opts{$_}) } keys %opts) > 1) {
		print STDERR "Error: only one action may be specified at once.\n";
                show_help();
                bail(1);
	} elsif (((scalar grep { /../ && defined($opts{$_}) } keys %opts) < 1) && (!defined($ARGV[0]))) {
		print STDERR "Error: no action specified.  Nothing to do.\n";
		show_help();
		bail(1);
        }


	# if we still have privleges (ie, we're using the sysytem config) then drop them now
	unless (($EUID == $UID) && ($EGID == $GID)) {
		($EUID, $EGID) = ($UID, $GID);
		unless (($EUID == $UID) && ($EGID == $GID)) {
			$ret = $!;
			putlog('debug', "Dropping privleges after config read failed: $EUID/$EGID <=> $UID/$GID: $ret");
			print STDERR "Fatal: dropping elevated privledges failed: $ret\n";
			bail(1);
		}
		putlog('debug', "Dropping privledges after reading config file: " . getpwuid($EUID) . "/" . getgrgid($EGID));
	}

	putlog('debug', "Running as " . scalar getpwuid($EUID) ."($EUID) for " . scalar getpwuid($UID) . "($UID) on $tty");

	putlog('debug', "Privledges dropped.  Untainting command line...");
	foreach (keys %opts) {
		$opts{$_} =~ /(.*)/;
		$opts{$_} = $1;
	}
	foreach ($buf = 0; defined($ARGV[$buf]); $buf++) {
		$ARGV[$buf] =~ /(.*)/;
		$ARGV[$buf] = $1;
	}

	# setup signal handlers to do a clean exit
	foreach ('HUP', 'INT', 'QUIT', 'TERM') {
		$SIG{$_} = sub {
			print STDERR "Aborting: trapped signal $_[0]\n";
			bail(1);
		}
	}

	unless (umask(077)) {
		$ret = $!;
		putlog('err',  "Fatal: unable to set umask to 077: $ret");
		print STDERR "Fatal: unable to set umask to 077: $ret\n";
		bail(1);
	}

	# if we intend using a file, we need to make the path
	# absolute before we change working directory.
	if ($opts{'f'} && ($opts{'f'} !~ m!^/!)) {
		$opts{'f'} = sprintf "%s/%s", getcwd(), $opts{'f'};
	}
	if ($opts{'F'} && ($opts{'F'} !~ m!^/!)) {
		$opts{'F'} = sprintf "%s/%s", getcwd(), $opts{'F'};
		$HIST = 1; # only the latest key is saved to file
	}

	eval { $TEMPDIR = tempdir("$ARGV0.XXXXXX", DIR => "/var/tmp/" ); };
	if (($@ ne "") || (!defined($TEMPDIR))) {
		$ret = $@;
		putlog('err', "Error creating temporary directory: $ret");
		print STDERR "Fatal: unable to create temporary directory: $ret\n";
		bail(1);
	}

	putlog('debug', "Created temporary working directory: $TEMPDIR");
	$ENV{'GNUPGHOME'} = "$TEMPDIR";
	
        unless (chdir($TEMPDIR)) {
		$ret = $!;
                putlog('err',  "Error switching to temporary directory: $TEMPDIR: $ret");
                print STDERR "Fatal: unable to chdir to $TEMPDIR: $ret\n";
                bail(1);
        }
	
	unless ($DBHAND = connect_db($DBNAME, $DBHOST, $DBUSER, $DBPASS)) {
		print STDERR "Fatal: unable to open database connection.\n";
		bail(1);
	}

	# if we're initalising, there are no passwords, so do this first
	if ($opts{'initialise'}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to initilise repository by non-owner");
			print STDERR "Fatal: only the script owner can run --initilise\n";
			bail(1);
		}

		if (check_keys($user)) {
			putlog('err', "Attempted to initialise but owner keys already exist.");
			print STDERR "Already initilised.\n";
			bail(1);
		}

		unless (create_keys($user)) {
			putlog('err', "Error while creating the initial owner key pair.");
			print STDERR "Initlialization failed.\n";
			bail(1);
		}

		putlog('notice', "Initial owner key pair successfully initialised.");
		print STDOUT "Database initialised.\n";
		bail(0);
	}

	# if changing their own password, just let gpg do the work.
	if (($opts{'change-pass'}) && (!(defined($ARGV[0])))) {
		unless (($user) && (change_key($user))) {
			putlog('err', "Error while changing the password for $user.");
			print STDERR "Password change failed.\n";
			bail(1);
		}
		putlog('notice', "Successfully changed the password for $user");
		bail(0);
	}

	# all other functions reqire authorization of the calling user
	$pass = get_passwd("Enter your password", 0);
	unless (($user) && (check_keys($user)) && (check_auth($user, $pass))) {
		putlog('notice', "Incomplete: Authorization refused.");
		print STDERR "Authorization refused.\n";
		bail(1);
	}

	if ($opts{'create-user'}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to create a user by non-owner");
			print STDERR "Fatal: only the script owner can run --create-user\n";
			bail(1);
		}

		if (check_keys($opts{'create-user'})) {
			putlog('err', "Attempted to create user " . $opts{'create-user'} . " but keys already exist.");
			print STDERR "Fatal: keys for " . $opts{'create-user'} . " already exist.\n";
			bail(1);
		}

		unless (create_keys($opts{'create-user'})) {
			putlog('err', "Error while creating the user key pair for " . $opts{'create-user'} . ".");
			print STDERR "User creation failed.\n";
			bail(1);
		}

		putlog('notice', "User key for " . $opts{'create-user'} . " pair successfully created.");
		print STDOUT "User " . $opts{'create-user'} . " created.\n";
		bail(0);
	} elsif ($opts{'delete-user'}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to delete a user by non-owner");
			print STDERR "Fatal: only the script owner can run --delete-user\n";
			bail(1);
		}

		if ($user eq $opts{'delete-user'}) {
			putlog('warning', "Attempt by $user to delete themselves.");
			print STDERR "Fatal: unable to delete own keys.\n";
			bail(1);
		}

		unless (check_keys($opts{'delete-user'})) {
			putlog('err', "Attempted to delete user " . $opts{'delete-user'} . " but keys don't exist.");
			print STDERR "Fatal: keys for " . $opts{'delete-user'} . " don't exist.\n";
			bail(1);
		}

		unless (delete_keys($opts{'delete-user'})) {
			putlog('err', "Error while deleting the user key pair for " . $opts{'delete-user'} . ".");
			print STDERR "User deletion failed.\n";
			bail(1);
		}

		foreach (get_user_access($opts{'delete-user'})) {	
			$before{$_} = 1;
		}

		unless (cleanup_user($opts{'delete-user'})) {
			putlog('err', "Error while cleaning up refences to user " . $opts{'delete-user'} . ".");
			print STDERR "User cleanup failed.\n";
			bail(1);
		}
			
		
		$ret = 0;
		foreach (keys(%before)) {
			putlog('debug', "Accesss for " . $opts{'delete-user'} . " to $_ has changed.  Re-encrypting...");
			unless (encrypt_asc($_, $user, $pass, undef)) {
				putlog('err', "Error while updating the key $_.");
				print STDERR "Update of $_ failed.\n";
				$ret = 1;
			}
		}

		putlog('notice', "User key for " . $opts{'delete-user'} . " pair successfully deleted.");
		print STDOUT "User " . $opts{'delete-user'} . " deleted.\n";
		bail(0);
	} elsif ($opts{'show-user'}) {
		unless (check_keys($opts{'show-user'})) {
			putlog('err', "Attempted to display user " . $opts{'show-user'} . " but keys don't exist.");
			print STDERR "Fatal: keys for " . $opts{'show-user'} . " don't exist.\n";
			bail(1);
		}

		unless (show_user($opts{'show-user'})) {
			putlog('err', "Error while display details for " . $opts{'show-user'} . ".");
			print STDERR "User display failed.\n";
			bail(1);
		}

		putlog('notice', "User details for " . $opts{'show-user'} . " successfully displayed.");
		bail(0);
	} elsif ($opts{'list-users'}) {
		if (defined($ARGV[0])) {
			$opts{'list-users'} = $ARGV[0];
		} else {
			$opts{'list-users'} = '.';
		}

		unless (list_users($opts{'list-users'})) {
			putlog('err', "Error while listing users matching pattern: " . $opts{'list-users'});
			print STDERR "User listing failed.\n";
			bail(1);
		}

		putlog('notice', "Successfully listed users matching pattern: " . $opts{'list-users'});
		bail(0);
	} elsif ($opts{'change-pass'}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to change another user's password  by non-owner");
			print STDERR "Fatal: only the script owner can run --change-pass for other users.\n";
			bail(1);
		}

		$buf = $ARGV[0];
		putlog('debug', "Resetting password for $buf by creating replacement keys...");
		unless (create_keys($buf)) {
			putlog('err', "Error while creating the user key pair for $buf.");
			print STDERR "Password change failed.\n";
			bail(1);
		}

		# it's an all new key, so re-encrypt everything they access
		foreach (get_user_access($buf)) {	
			putlog('debug', "Accesss for $buf to $_ has changed.  Re-encrypting...");
			print STDOUT "Updating $_...\n";
			unless (encrypt_asc($_, $user, $pass, undef)) {
				putlog('err', "Error while updating the key $_.");
				print STDERR "Update of $_ failed.\n";
				$ret = 1;
			}
		}
		bail(1) if ($ret);

		putlog('notice', "Successfully changed the password for $buf");
		bail(0);
	} elsif ($opts{'create-group'}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to create a group by non-owner");
			print STDERR "Fatal: only the script owner can run --create-group\n";
			bail(1);
		}

		if (check_group($opts{'create-group'})) {
			putlog('err', "Attempted to create group " . $opts{'create-group'} . " but it already exist.");
			print STDERR "Fatal: group " . $opts{'create-group'} . " already exist.\n";
			bail(1);
		}

		unless (cleanup_group($opts{'create-group'})) {
			putlog('err', "Error while clearing existing membership list of " . $opts{'create-group'} . ".");
			print STDERR "Fatal: membership of " . $opts{'create-group'} . " not cleared.\n";
			bail(1);
		}

		unless (create_group($opts{'create-group'})) {
			putlog('err', "Error while creating the group " . $opts{'create-group'} . ".");
			print STDERR "Group creation failed.\n";
			bail(1);
		}

		if (defined($ARGV[0])) {
			$ret = 0;
			foreach $buf (split/,/, $ARGV[0]) {
				unless (check_keys($buf)) {
					putlog('err', "Attempted to add user $buf to group " . $opts{'create-group'} . " but keys don't exist.");
					print STDERR "Error: keys for $buf don't exist.\n";
					$ret = 1;
					next;
				}
				unless (add_to_group($opts{'create-group'}, $buf)) {
					putlog('err', "Error while setting up initial member of " . $opts{'create-group'} . ": $buf");
					print STDERR "Error: unable to add $buf to group.\n";
					$ret = 1;
				}
			}
			bail(1) if ($ret);
		}

		putlog('notice', "Group " . $opts{'create-group'} . " successfully created.");
		print STDOUT "Group " . $opts{'create-group'} . " created.\n";
		bail(0);
	} elsif ($opts{'delete-group'}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to create a group by non-owner");
			print STDERR "Fatal: only the script owner can run --delete-group\n";
			bail(1);
		}

		unless (check_group($opts{'delete-group'})) {
			putlog('err', "Attempted to delete group " . $opts{'delete-group'} . " but it doesn't exist.");
			print STDERR "Fatal: group " . $opts{'delete-group'} . " doesn't exist.\n";
			bail(1);
		}

		unless (delete_group($opts{'delete-group'})) {
			putlog('err', "Error while creating the group " . $opts{'delete-group'} . ".");
			print STDERR "Group deletion failed.\n";
			bail(1);
		}

		putlog('debug', "Getting 'before' list of accessible keys for " . $opts{'delete-group'} . " ...");
		foreach (get_group_access($opts{'delete-group'})) {	
			$before{$_} = 1;
		}
		foreach (get_group_denies($opts{'delete-group'})) {	
			$before{$_} = 1;
		}

		unless (cleanup_group($opts{'delete-group'})) {
			putlog('err', "Error while clearing existing membership list of " . $opts{'delete-group'} . ".");
			print STDERR "Fatal: membership of " . $opts{'delete-group'} . " not cleared.\n";
			bail(1);
		}

		$ret = 0;
		foreach (keys(%before)) {
			putlog('debug', "Accesss for " . $opts{'delete-group'} . " to $_ has changed.  Re-encrypting...");
			print STDOUT "Updating $_...\n";
			unless (encrypt_asc($_, $user, $pass, undef)) {
				putlog('err', "Error while updating the key $_.");
				print STDERR "Update of $_ failed.\n";
				$ret = 1;
			}
		}

		putlog('notice', "Group " . $opts{'delete-group'} . " successfully deleted.");
		print STDOUT "Group " . $opts{'delete-group'} . " deleted.\n";
		bail(0);
	} elsif ($opts{'show-group'}) {
		unless (check_group($opts{'show-group'})) {
			putlog('err', "Attempted to display group " . $opts{'show-group'} . " but it doesn't exist.");
			print STDERR "Fatal: group " . $opts{'show-group'} . " doesn't exist.\n";
			bail(1);
		}

		unless (show_group($opts{'show-group'})) {
			putlog('err', "Error while display details for " . $opts{'show-group'} . ".");
			print STDERR "Group display failed.\n";
			bail(1);
		}

		putlog('notice', "Group details for " . $opts{'show-group'} . " successfully displayed.");
		bail(0);
	} elsif ($opts{'list-groups'}) {
		if (defined($ARGV[0])) {
			$opts{'list-groups'} = $ARGV[0];
		} else {
			$opts{'list-groups'} = '.';
		}

		unless (list_groups($opts{'list-groups'})) {
			putlog('err', "Error while listing groups matching pattern: " . $opts{'list-groups'});
			print STDERR "Group listing failed.\n";
			bail(1);
		}

		putlog('notice', "Successfully listed groups matching pattern: " . $opts{'list-groups'});
		bail(0);
	} elsif ($opts{'add-grp-access'}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to add to a group by non-owner");
			print STDERR "Fatal: only the script owner can run --add-grp-access\n";
			bail(1);
		}

		unless (defined($ARGV[0])) {
			print STDERR "Error: no members specified to be added to group.\n";
	                show_help();
			bail(1);
        	}

		unless (check_group($opts{'add-grp-access'})) {
			putlog('err', "Attempted to add to group " . $opts{'add-grp-access'} . " but it doesn't exist.");
			print STDERR "Fatal: group " . $opts{'add-grp-access'} . " doesn't exist.\n";
			bail(1);
		}

		%encrypt = ();
		$ret = 0;
		foreach $buf (split/,/, $ARGV[0]) {
			unless (check_keys($buf)) {
				putlog('err', "Attempted to add user $buf to group " . $opts{'add-grp-access'} . " but keys don't exist.");
				print STDERR "Error: keys for $buf don't exist.\n";
				$ret = 1;
				next;
			}

			%before = ();
			putlog('debug', "Getting 'before' list of accessible keys for $buf ...");
			foreach (get_user_access($buf)) {	
				$before{$_} = 1;
			}

			unless (add_to_group($opts{'add-grp-access'}, $buf)) {
				putlog('err', "Error while adding member to " . $opts{'add-grp-access'} . ": $buf");
				print STDERR "Error: unable to add $buf to group.\n";
				$ret = 1;
			}

			%after = ();	
			putlog('debug', "Getting 'after' list of accessible keys for $buf ...");
			foreach (get_user_access($buf)) {	
				$after{$_} = 1;
			}

			foreach (keys(%before), keys(%after)) {
				next if (($before{$_}) && ($after{$_}));
				$encrypt{$_} = 1;
			}
		}
		bail(1) if ($ret);

		$ret = 0;
		foreach (keys(%encrypt)) {
			putlog('debug', "Accesss to $_ has changed.  Re-encrypting...");
			print STDOUT "Updating $_...\n";
			unless (encrypt_asc($_, $user, $pass, undef)) {
				putlog('err', "Error while updating the key $_.");
				print STDERR "Update of $_ failed.\n";
				$ret = 1;
			}
		}
		bail(1) if ($ret);

		putlog('notice', "Members succesfully added to group  " . $opts{'add-grp-access'} . ": $ARGV[0]");
		print STDOUT "Members succesfully added to " . $opts{'add-grp-access'} . "\n";
		bail(0);
	} elsif ($opts{'rem-grp-access'}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to add to a group by non-owner");
			print STDERR "Fatal: only the script owner can run --rem-grp-access\n";
			bail(1);
		}

		unless (defined($ARGV[0])) {
			print STDERR "Error: no members specified to be removed from group.\n";
	                show_help();
			bail(1);
        	}

		unless (check_group($opts{'rem-grp-access'})) {
			putlog('err', "Attempted to remove from group " . $opts{'rem-grp-access'} . " but it doesn't exist.");
			print STDERR "Fatal: group " . $opts{'rem-grp-access'} . " doesn't exist.\n";
			bail(1);
		}


		%encrypt = ();
		$ret = 0;
		foreach $buf (split/,/, $ARGV[0]) {
			unless (check_keys($buf)) {
				putlog('err', "Attempted to remove user $buf from group " . $opts{'rem-grp-access'} . " but keys don't exist.");
				print STDERR "Error: keys for $buf don't exist.\n";
				$ret = 1;
				next;
			}

			%before = ();
			putlog('debug', "Getting 'before' list of accessible keys for $buf ...");
			foreach (get_user_access($buf)) {	
				$before{$_} = 1;
			}

			unless (rem_from_group($opts{'rem-grp-access'}, $buf)) {
				putlog('err', "Error while removing member from " . $opts{'rem-grp-access'} . ": $buf");
				print STDERR "Error: unable to add $buf to group.\n";
				$ret = 1;
			}

			%after = ();
			putlog('debug', "Getting 'after' list of accessible keys for $buf ...");
			foreach (get_user_access($buf)) {	
				$after{$_} = 1;
			}

			foreach (keys(%before), keys(%after)) {
				next if (($before{$_}) && ($after{$_}));
				$encrypt{$_} = 1;
			}
		}
		bail(1) if ($ret);

		$ret = 0;
		foreach (keys(%encrypt)) {
			putlog('debug', "Accesss to $_ has changed.  Re-encrypting...");
			print STDOUT "Updating $_...\n";
			unless (encrypt_asc($_, $user, $pass, undef)) {
				putlog('err', "Error while updating the key $_.");
				print STDERR "Update of $_ failed.\n";
				$ret = 1;
			}
		}
		bail(1) if ($ret);

		putlog('notice', "Members succesfully removed from group " . $opts{'rem-grp-access'} . ": $ARGV[0]");
		print STDOUT "Members succesfully removed from group " . $opts{'rem-grp-access'} . "\n";
		bail(0);
	} elsif ($opts{'create-key'}) {
		if (check_asc($opts{'create-key'})) {
			unless (check_rate($opts{'create-key'})) {
				putlog('err', "Attempted to change key " . $opts{'create-key'} . " but rate exceeded.");
				print STDERR "Fatal: key " . $opts{'create-key'} . " changing too often.\n";
				bail(1);
			}
		} else {
			unless (defined($ARGV[0])) {
				print STDERR "Error: no initial access specified for new key.\n";
		                show_help();
				bail(1);
	        	}
	
			$ret = 0;
			foreach $buf (split/,/, $ARGV[0]) {
				if ($buf =~ s/^-//) {
					$mod = "-";
				} else {
					$mod = "";
				}
				if ($buf =~ s/^\@//) {
					$grp = "@";
					unless (check_group($buf)) {
						putlog('err', "Attempted to add $mod\@$buf to key " . $opts{'create-key'} . " but it doesn't exist.");
						print STDERR "Error: group " . $buf . " doesn't exist.\n";
						$ret = 1;
						next;
					}
				} else {
					unless (check_keys($buf)) {
						putlog('err', "Attempted to add $mod$buf to key " . $opts{'create-key'} . " but keys don't exist.");
						print STDERR "Error: user $buf don't exist.\n";
						$ret = 1;
						next;
					}
					$grp = "";
				}
				unless (add_to_asc($opts{'create-key'}, "$mod$grp$buf")) {
					putlog('err', "Error while granting initial access to " . $opts{'create-key'} . ": $mod$grp$buf");
					print STDERR "Error: unable to add $mod$grp$buf to key.\n";
					$ret = 1;
				}
			}
			bail(1) if ($ret);
		}

		if ($opts{'f'}) {
			unless ($buf = read_passfile($opts{'f'})) {
				putlog('err', "Failed to read the password from file: " . $opts{'f'});
				print STDERR "Error: failed to read from file: " . $opts{'f'} . "\n";
				bail(1);
			} 
		} else {
			$buf = get_passwd("New password for " . $opts{'create-key'}, 1);
		}

		unless (encrypt_asc($opts{'create-key'}, $user, undef, $buf)) {
			putlog('err', "Error while creating the key " . $opts{'create-key'} . ".");
			print STDERR "Key creation failed.\n";
			bail(1);
		}

		putlog('notice', "Key " . $opts{'create-key'} . " successfully created.");
		print STDOUT "Key " . $opts{'create-key'} . " created.\n";
		bail(0);
	} elsif ($opts{'delete-key'}) {
		unless (check_asc($opts{'delete-key'})) {
			putlog('err', "Attempted to delete key " . $opts{'delete-key'} . " but it doesn't exist.");
			print STDERR "Fatal: key " . $opts{'delete-key'} . " doesn't exist.\n";
			bail(1);
		}

		unless ($OWNER) {
			unless (fetch_asc($opts{'delete-key'}, undef)) {
				putlog('err', "Error while fetching key " . $opts{'delete-key'});
				print STDERR "Error: unable to fetch key " . $opts{'delete-key'} . "\n";
				bail(1);
			}
				
			unless ($buf = decrypt_asc($user, $pass, $opts{'delete-key'})) {
				putlog('err', "Error while decrypting key " . $opts{'delete-key'});
				print STDERR "Error: unable to decrypt key " . $opts{'delete-key'} . "\n";
				bail(1);
			}
		}

		unless (delete_asc($opts{'delete-key'})) {
			putlog('err', "Error while fetching key " . $opts{'delete-key'});
			print STDERR "Error: unable to fetch key " . $opts{'delete-key'} . "\n";
			bail(1);
		}

		putlog('notice', "Key " . $opts{'delete-key'} . " successfully deleted.");
		print STDOUT "Key " . $opts{'delete-key'} . " deleted.\n";
		bail(0);
	} elsif ($opts{'change-key'}) {
		unless (check_asc($opts{'change-key'})) {
			putlog('err', "Attempted to change key " . $opts{'change-key'} . " but it doesn't exist.");
			print STDERR "Fatal: key " . $opts{'change-key'} . " doesn't exist.\n";
			bail(1);
		}

		unless (check_rate($opts{'change-key'})) {
			putlog('err', "Attempted to change key " . $opts{'change-key'} . " but rate exceeded.");
			print STDERR "Fatal: key " . $opts{'change-key'} . " changing too often.\n";
			bail(1);
		}

		if ($opts{'f'}) {
			unless ($buf = read_passfile($opts{'f'})) {
				putlog('err', "Error while reading the password from file: " . $opts{'f'});
				print STDERR "Error: unable to read from file: " . $opts{'f'} . "\n";
				bail(1);
			} 
		} else {
			$buf = get_passwd("New password for " . $opts{'change-key'}, 1);
		}

		unless (encrypt_asc($opts{'change-key'}, $user, undef, $buf)) {
			putlog('err', "Error while creating the key " . $opts{'change-key'} . ".");
			print STDERR "Key creation failed.\n";
			bail(1);
		}

		putlog('notice', "Key " . $opts{'change-key'} . " successfully changed.");
		print STDOUT "Key " . $opts{'change-key'} . " changed.\n";
		bail(0);
	} elsif ($opts{'list-keys'}) {
		if (defined($ARGV[0])) {
			$opts{'list-keys'} = $ARGV[0];
		} else {
			$opts{'list-keys'} = '.';
		}

		unless (list_keys($opts{'list-keys'})) {
			putlog('err', "Error while listing keys matching pattern: " . $opts{'list-keys'});
			print STDERR "Key listing failed.\n";
			bail(1);
		}

		putlog('notice', "Successfully listed keys matching pattern: " . $opts{'list-keys'});
		bail(0);
	} elsif ($opts{'add-key-access'}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to add access to a key by non-owner");
			print STDERR "Fatal: only the script owner can run --add-key-access\n";
			bail(1);
		}

		unless (defined($ARGV[0])) {
			print STDERR "Error: no members specified to be added to key.\n";
	                show_help();
			bail(1);
        	}

		unless (check_asc($opts{'add-key-access'})) {
			putlog('err', "Attempted to grant access to " . $opts{'add-key-access'} . " but it doesn't exist.");
			print STDERR "Fatal: key " . $opts{'add-key-access'} . " doesn't exist.\n";
			bail(1);
		}

		if (defined($ARGV[0])) {
			$ret = 0;
			foreach $buf (split/,/, $ARGV[0]) {
				if ($buf =~ s/^-//) {
					$mod = "-";
				} else {
					$mod = "";
				}
				if ($buf =~ s/^\@//) {
					$grp = "@";
					unless (check_group($buf)) {
						putlog('err', "Attempted to add $mod\@$buf to key " . $opts{'add-key-access'} . " but it doesn't exist.");
						print STDERR "Error: group " . $buf . " doesn't exist.\n";
						$ret = 1;
						next;
					}
				} else {
					unless (check_keys($buf)) {
						putlog('err', "Attempted to add $mod$buf to key " . $opts{'add-key-access'} . " but keys don't exist.");
						print STDERR "Error: user $buf don't exist.\n";
						$ret = 1;
						next;
					}
					$grp = "";
				}
				unless (add_to_asc($opts{'add-key-access'}, "$mod$grp$buf")) {
					putlog('err', "Error while granting access to " . $opts{'add-key-access'} . ": $mod$grp$buf");
					print STDERR "Error: unable to add $mod$grp$buf to key.\n";
					$ret = 1;
				}
			}
			bail(1) if ($ret);
		}

		unless (encrypt_asc($opts{'add-key-access'}, $user, $pass, undef)) {
			putlog('err', "Error while updating the key " . $opts{'add-key-access'} . ".");
			print STDERR "Key update failed.\n";
			bail(1);
		}

		putlog('notice', "Key " . $opts{'add-key-access'} . " access updated.");
		print STDOUT "Key " . $opts{'add-key-access'} . " access updated.\n";
		bail(0);
	} elsif ($opts{'rem-key-access'}) {
		unless ($OWNER) {
			putlog('warning', "Attempt to remove access to a by non-owner");
			print STDERR "Fatal: only the script owner can run --rem-key-access\n";
			bail(1);
		}

		unless (defined($ARGV[0])) {
			print STDERR "Error: no members specified to be removed from key.\n";
	                show_help();
			bail(1);
        	}

		unless (check_asc($opts{'rem-key-access'})) {
			putlog('err', "Attempted to remove access from " . $opts{'rem-key-access'} . " but it doesn't exist.");
			print STDERR "Fatal: key " . $opts{'rem-key-access'} . " doesn't exist.\n";
			bail(1);
		}

		if (defined($ARGV[0])) {
			$ret = 0;
			foreach $buf (split/,/, $ARGV[0]) {
				# modifier doens't matter here, just strip it
				$buf =~ s/^-//;  # modifier doens't matter here, just strip it
				if ($buf =~ s/^\@//) {
					$grp = "@";
					unless (check_group($buf)) {
						putlog('err', "Attempted to remove \@$buf to key " . $opts{'rem-key-access'} . " but it doesn't exist.");
						print STDERR "Error: group " . $buf . " doesn't exist.\n";
						$ret = 1;
						next;
					}
				} else {
					unless (check_keys($buf)) {
						putlog('err', "Attempted to remove $buf to key " . $opts{'rem-key-access'} . " but keys don't exist.");
						print STDERR "Error: user $buf don't exist.\n";
						$ret = 1;
						next;
					}
					$grp = "";
				}
				unless (rem_from_asc($opts{'rem-key-access'}, "$grp$buf")) {
					putlog('err', "Error while granting access to " . $opts{'rem-key-access'} . ": $grp$buf");
					print STDERR "Error: unable to add $grp$buf to key.\n";
					$ret = 1;
				}
			}
			bail(1) if ($ret);
		}

		unless (encrypt_asc($opts{'rem-key-access'}, $user, $pass, undef)) {
			putlog('err', "Error while updating the key " . $opts{'rem-key-access'} . ".");
			print STDERR "Key update failed.\n";
			bail(1);
		}

		putlog('notice', "Key " . $opts{'rem-key-access'} . " access updated.");
		print STDOUT "Key " . $opts{'rem-key-access'} . " access updated.\n";
		bail(0);
	} elsif ($opts{'show-key'}) {
		unless (check_asc($opts{'show-key'})) {
			putlog('err', "Attempted to key key " . $opts{'show-key'} . " but it doesn't exist.");
			print STDERR "Fatal: key " . $opts{'show-key'} . " doesn't exist.\n";
			bail(1);
		}

		unless (show_key($opts{'show-key'})) {
			putlog('err', "Error while display details for " . $opts{'show-key'} . ".");
			print STDERR "Key display failed.\n";
			bail(1);
		}

		putlog('notice', "Key details for " . $opts{'show-key'} . " successfully displayed.");
		bail(0);
	}
	
	if ($ARGV[0]) {
		unless (check_asc($ARGV[0])) {
			putlog('err', "Attempted to decrypt key " . $ARGV[0] . " but it doesn't exist.");
			print STDERR "Fatal: key " . $ARGV[0] . " doesn't exist.\n";
			bail(1);
		}

		unless ((scalar grep { /^\Q$ARGV[0]\E$/ } get_user_access($user)) > 0) {
			putlog('err', "No permissions for $user to access key " . $ARGV[0]);
			print STDERR "Error: permission denied.\n";
			bail(1);
		}

		$ret = 1;
		foreach $upd (get_updates($ARGV[0], $HIST)) {
			unless (fetch_asc($ARGV[0], $upd)) {
				putlog('err', "Error while fetching key " . $ARGV[0]);
				print STDERR "Error: unable to fetch key " . $ARGV[0] . "\n";
				bail(1);
			}
			if ($buf = decrypt_asc($user, $pass, $ARGV[0])) {
				if ($buf =~ /^=\?[^?]+\?B?(.*)\?=/) {
					$buf = decode_base64($1);
				}
				if ($opts{'F'}) {
					unless (save_passfile($opts{'F'}, $buf)) {
						putlog('err', "Error while saving the password to file: " . $opts{'F'});
						print STDERR "Error: unable to save to file: " . $opts{'F'} . "\n";
						bail(1);
					}
					print "Pass from $upd saved to " . $opts{'F'} . "\n";
					bail(0);
				}
				$buf .= "\n" if ($buf !~ /\n$/);
				push(@out, "######### $upd ########## \n$buf");
				$ret = 0;
			} elsif ($ret == 1) {
				# if we have the first key, carry on regardless
				putlog('err', "Error while decrypting key " . $ARGV[0]);
				print STDERR "Error: unable to decrypt key " . $ARGV[0] . "\n";
				bail(1);
			}
		}
	
		# reverse the order for the output
		for ($buf = $#out; $buf >= 0; $buf--) {
			print $out[$buf];
		}
		bail(0);
	}

	putlog('err', "The end of main() reached.  No action performed.");
	print STDERR "Fatal: no action performed.\n";
	bail(1);
}

# SUB FUNCS ################################################################

sub bail ($) {
	my($code) = $_[0];
	my($d);

	if (defined($TERMIOS)) {
		$TERMIOS->setlflag($TTYFLAGS);
		$TERMIOS->setattr(0, TCSANOW);
		$TERMIOS = undef;
	}

	exit($code) if (($DEBUG) && ($code));

	if ((defined($TEMPDIR)) && ( -d $TEMPDIR)) {
		if (opendir($d, $TEMPDIR))  {
			foreach (readdir($d)) {
				/(.+)/;
				unlink("$TEMPDIR/$1");
				rmdir("$TEMPDIR/$1");
			}
			closedir($d);
		}
		rmdir($TEMPDIR);
	}
		
        exit($_[0]);
}

sub show_help () {
	print STDOUT "$ARGV0 version $VER

usage: $ARGV0 [<opts>] [<key>]


--version|-v	show the version of the program.
--help|-h	causes this message to be shown.

--debug|-d	enable more verbose logging.
--no-debug|-D	disable more verbose logging.

--history|-H <int>
	

--from-file <file>
	Read the key phrase to be encypted from the specified file.
	For use with the --change-key and --create-key options.

--to-file <file>
	Save the retrieved key to the specified file. for use with
	the default display key action.

Only one of:

--create-user <user>
--delete-user <user>
--show-user <user>
--list-users [regex]
--create-group <group> [user1][,user2]...
--delete-group <group>
--show-group [group]
--list-groups [regex]
--add-grp-access <group> <user1>[,user2]...
--rem-grp-access <group> <user1>[,user2]...
--create-key <key> [-]<user1|\@group1>[,[-]<user2|\@group2>]...
--delete-key <key>
--change-key <key>
--list-keys [regex]
--show-key <key>
--add-key-access <key> <[-]<user1|\@group1>[,[-]<user2|\@group2>]...
--rem-key-access <key> <user1|\@group1>[,<user2|\@group2>]...
--change-pass

If none of the above is specified the default action is
to decrypt the requested key and show the password.
\n";
	return();
}

sub putlog ($$) {
	my($pri) = $_[0];
	my($msg) = $_[1];

	chomp($msg);

	return() unless (($pri ne "debug") || ($DEBUG));

	$msg =~ s/([^\012\040-\176])/sprintf("\\%03o", unpack("C", $1))/eg;

	eval {
		openlog($ARGV0, 'ndelay,pid', 'authpriv');
		syslog($pri, "%s", $msg);
		closelog();
	};

	if ($@ ne "") {
		chomp($@);
		$@ =~ s/^.*\n//s;
		print "Unable to log via syslog: $@\n";
		print STDERR "" . strftime("%b %d %T", localtime) . ": syslog failed: $@\n"
	}

	print STDERR "" . scalar localtime () . ": $msg\n" if ($DEBUG);
}

sub connect_db($$$$) {
	my($db) = $_[0];
	my($host) = $_[1];
	my($user) = $_[2];
	my($pass) = $_[3];
	my($hand);

	putlog('debug', "Connecting to $db\@$host as $user ...");

        $hand = DBI->connect("DBI:mysql:database=$db;host=$host", $user, $pass, {
		PrintError => 0
	});

	unless ($hand) {
		putlog('err', "Unable to connect to DB $db\@$host: $DBI::errstr");
		return(undef);
	}

	putlog('debug', "Succesfully connected to DB $db\@$host.");

        return($hand);
}

sub get_passwd ($$) {
	my($prompt) = $_[0];
	my($confirm) = $_[1];
	my($buf, $key);

	if (ttyname(fileno(0))) {
		$TERMIOS = POSIX::Termios->new();
	
		$TERMIOS->getattr(0);
		$TTYFLAGS = $TERMIOS->getlflag();
	
		$TERMIOS->setlflag($TTYFLAGS &~ (ECHO | ECHOK | ICANON));
		$TERMIOS->setattr(0, TCSANOW);
	} else {
		$confirm = 0;
	}

	$key = 0;
	while ($buf ne $key) {
		print STDERR "Passwords do not match!\n" if ($key);
		print STDOUT "$prompt: ";
		$key = <STDIN>;
		print STDOUT "\n";
		if ($confirm) {
			print STDOUT "Re-enter to confirm: ";
			$buf = <STDIN>;
			print STDOUT "\n";
		} else {
			last;
		}
	}

	if (defined($TERMIOS)) {
		$TERMIOS->setlflag($TTYFLAGS);
		$TERMIOS->setattr(0, TCSANOW);
		$TERMIOS = undef;
	}

	return($key);
}

sub read_passfile ($) {
	my($file) = $_[0];
	my($f, $buf, $cnt);

	unless ( -s $file) {
		putlog('err', "Pass file contains no data: $file");
		print STDERR "Error: the pass file contains no data: $file\n";
		return(undef);
	}

	unless (open($f, "<$file")) {
		putlog('err', "Unable to open pass file: $file: $!");
		print STDERR "Error: unable to open pass file: $file: $!\n";
		return(undef);
	}

	while (<$f>) {
		$buf .= $_;
		$cnt++;
	}

	close($f);

	if ($cnt == 1) {
		chomp($buf);
	}

	if (length($buf) < 1) {
		putlog('err', "No data read from the pass file: $file");
		print STDERR "Error: no data read from pass file: $file\n";
		return(undef);
	}

        if ($buf =~ /([^\020-\176])/) {
                $buf = encode_base64($buf, "");
                $buf = "=?us-ascii?B?$buf?="
        }

	return($buf);
}

sub save_passfile ($$) {
	my($file) = $_[0];
	my($pass) = $_[1];
	my($f);

	unless (open($f, ">$file")) {
		putlog('err', "Unable to open pass file: $file: $!");
		print STDERR "Error: unable to open pass file: $file: $!\n";
		return(undef);
	}

	print $f $pass;

	unless (close($f)) {
		putlog('err', "Unable to save pass file: $file: $!");
		print STDERR "Error: unable to save pass file: $file: $!\n";
		return(undef);
	}

	return(1);
}

sub read_config ($) {
        my($cfg) = $_[0];
        my(@stat, $ret);

	return(1) unless defined($CFGFILE);

	putlog('debug', "Reading config file $cfg ...");

	unless (@stat = stat($cfg)) {
		$ret = $!;
		putlog('err', "Unable to stat config file: $cfg: $ret");
		print STDERR "Error: unable to stat config file: $cfg: $ret\n";
		return(0);
	}

	unless ($stat[4] == $EUID) {
		putlog('err', "Insecure owner on config: $cfg: " . scalar getpwuid($stat[4]) . "(" . $stat[4] . ") != " . scalar getpwuid($EUID) . "($EUID)");
		print STDERR "Error: wrong owner on config file: $cfg: " . $stat[4] . "\n";
		return(0);
	}

	unless (($stat[2] & 00077) == 0) {
		putlog('err', sprintf "Insecure permissions on config: $cfg: %04o", ($stat[2] & 07777));
		printf STDERR "Error: insecure mode on config file: $cfg: %04o\n", ($stat[2] & 07777);
		return(0);
	}

        unless ($ret = do ($cfg)) {
                if ($@) {
			$@ =~ s/^.*\n//s;
			putlog('err', "Unable to read config file: $cfg: $@");
                        return(0);
                }
                unless (defined ($ret)) {
			putlog('err', "Error while read config file: $cfg: $!");
			return(0);
                }
                putlog('err', "Error in config file $cfg: $ret");
		return(0);
        }

	putlog('debug', "Succesfully read config file $cfg: $ret");

        return (1);
}

sub check_keys ($) {
	my($usr) = $_[0];
	my($p, $buf, $out, $ret, $file);

	putlog('debug', "Checking validity of keys for $usr ...");

	$usr =~ /^(.*)$/;
	$file = md5_hex($1);
	
	unless (( -f "$file.sec") && ( -f "$file.pub")) {
		return(0) unless (fetch_keys($usr));
	}

	$buf = open($p, "-|");

	unless (defined($buf)) {
		$ret = $!;
		putlog('err',  "Error: unable to fork gpg for key verification: $ret");
		print STDERR "Error: unable to fork gpg for key verification: $ret\n";
		return(0);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDIN) && open(STDIN, "</dev/null"))) {
			$ret = $!;
			putlog('err',  "Error: unable to map gpg's stdin to /dev/null: $ret");
			print STDERR "Error: unable to map gpg's stdin to /dev/null: $ret\n";
			bail(1);
		}       
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			$ret = $!;
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $ret");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $ret\n";
			bail(1);
		}       
		putlog('debug', join(" ", ('gpg1', '-q', '--no-secmem-warning',
			'--list-secret-keys', '--no-default-keyring',
			'--keyring', "$file.pub", '--secret-keyring', "$file.sec")));
		{ exec {'gpg1'} ('gpg1', '-q', '--no-secmem-warning',
			'--list-secret-keys', '--no-default-keyring',
			'--keyring', "$file.pub", '--secret-keyring', "$file.sec"); }
		$ret = $!;
		putlog('err',  "Error: unable to exec gpg for key verification: $ret");
		print STDERR "Error: unable to exec gpg for key verification: $ret\n";
		exit(1);
	}

	while (<$p>) {
		chomp();
		putlog('debug', "gpg: $_");
		next unless (/^(uid|sec)\s.+[ <(]($usr)[ @)]/);
		$out = $2;
	}

	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: key verifing gpg process was killed: $buf");
		print STDERR "Error: key verifing gpg process was killed: $buf\n";
		return(0);
	}

	unless ($out) {
		putlog('err', "Error key verification failed.");
		return(0);
	}

	putlog('debug', "Validation of keys for $usr succesfull.");

	return(1);
}

sub delete_keys ($) {
	my($usr) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Deleting keys for $usr from database...");

	$sql = "DELETE FROM users WHERE name = '$usr'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to delete " . $usr . "'s keys: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to delete " . $usr . "'s keys: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) affected by query: %s", $qry->rows(), $sql);

	putlog('debug', "Keys for $usr successfully deleted from database.");

	return(1);
}

sub fetch_keys ($) {
	my($usr) = $_[0];
	my($sql, $qry, $res);
	my($f, $file);

	putlog('debug', "Fetching keys for $usr from database...");

	$usr =~ /^(.*)$/;
	$file = md5_hex($1);

	$sql = "SELECT * FROM users WHERE name = '$usr'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $usr . "'s keys: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $usr . "'s keys: " . $qry->errstr);
		return(0);
	}

	$res = $qry->fetchrow_hashref();

	unless (defined($res)) {
		putlog('notice', "No keys for $usr are present in the database.");
		return(0);
	}

	unless ($res->{'name'} eq $usr) {
		# WTF? How did this happen!?? 
		putlog('err', "The query for " . $usr . "'s keys has returned " . $res->{'name'} . "'s keys.");
		return(0);
	}

	unless (open($f, ">$file.sec")) {
		putlog('err', "Unable to open key file for writing: $file.sec: $!");
		return(0);
	}

	unless (print $f $res->{'secret'}) {
		putlog('err', "Unable to write the key to file: $file.sec: $!");
		return(0);
	}

	unless (close($f)) {
		putlog('err', "Unable to save the key file after writing: $file.sec: $!");
		return(0);
	}

	unless (open($f, ">$file.pub")) {
		putlog('err', "Unable to open key file for writing: $file.pub: $!");
		return(0);
	}

	unless (print $f $res->{'public'}) {
		putlog('err', "Unable to write the key to file: $file.pub: $!");
		return(0);
	}

	unless (close($f)) {
		putlog('err', "Unable to save the key file after writing: $file.pub: $!");
		return(0);
	}

	putlog('debug', "Keys for $usr successfully fetched from database.");

	return(1);
}

sub save_keys ($) {
	my($usr) = $_[0];
	my($sql, $qry, $res);
	my($f, $file);

	putlog('debug', "Saving keys for $usr in database...");

	$sql = "SELECT * FROM users WHERE name = '$usr'";

	$usr =~ /^(.*)$/;
	$file = md5_hex($1);

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $usr . "'s keys: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $usr . "'s keys: " . $qry->errstr);
		return(0);
	}

	$res = $qry->fetchrow_hashref();

	unless (open($f, "<$file.sec")) {
		putlog('err', "Unable to open key file for reading: $file.sec: $!");
		return(0);
	}

	$res->{'secret'} = join("",  (<$f>));

	close($f);

	unless (open($f, "<$file.pub")) {
		putlog('err', "Unable to open key file for reading: $file.pub: $!");
		return(0);
	}

	$res->{'public'} = join("",  (<$f>));
	
	close($f);

	# could use REPLACE, but later we might want to presenve the timestamp
	if (defined($res->{'name'})) {
		$sql = "UPDATE users SET name = ?, secret = ?, public = ? WHERE name = '$usr'";
	} else {
		$sql = "INSERT INTO users VALUES ( ?, ?, ?, NULL)";
	}

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to save " . $usr . "'s keys: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute($usr, $res->{'secret'}, $res->{'public'})) {
		putlog('err', "Unable to execute SQL query to save " . $usr . "'s keys: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) affected by query: %s", $qry->rows(), $sql);

	putlog('debug', "Keys for $usr successfully saved database:" . $qry->errstr);

	return(1);
}

sub create_keys ($) {
	my($usr) = $_[0];
	my($buf, $key, @pwe, $ret);
	my($p, $file);

	unless (@pwe = getpwnam($usr)) {
		$ret = $!;
		putlog('err',  "Error: Can't find details for user $usr: $ret");
		print STDERR "Error: Can't find details for user $usr: $ret\n";
		return(0);
	}

	$usr =~ /^(.*)$/;
	$file = md5_hex($1);

	$pwe[6] = "$usr\@localhost" unless ($pwe[6]);

	$key = get_passwd("New password for $usr", 1);

	$buf = open($p, "|-");

	unless (defined($buf)) {
		$ret = $!;
		putlog('err',  "Error: unable to fork gpg for key creation: $ret");
		print STDERR "Error: unable to fork gpg for key creation: $ret\n";
		return(0);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			$ret = $!;
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $ret");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $ret\n";
			exit(1);
		}       
		putlog('debug', join(" ", ('gpg1', '--no-greeting', '--no-secmem-warning', 
			'--no-default-keyring',
			'--secret-keyring', '/dev/null', '--keyring', '/dev/null',
			'--batch', '--gen-key', '--yes', '-v', '--logger-fd', '1')));
		{ exec {'gpg1'} ('gpg1', '--no-greeting', '--no-secmem-warning', 
			'--no-default-keyring',
			'--secret-keyring', '/dev/null', '--keyring', '/dev/null',
			'--batch', '--gen-key', '--yes', '-v', '--logger-fd', '1'); }
		putlog('err',  "Error: unable to exec gpg for key creation: $!");
		exit(1);
	}

	print $p "
		%echo $pwe[6] ($usr) <$usr\@localhost>
		Key-Type: DSA
		Key-Length: 1024
		Subkey-Type: ELG-E
		Subkey-Length: 1024
		Name-Real: $pwe[6]
		Name-Comment: $usr
		Name-Email: $usr\@localhost
		Expire-Date: 0
		Passphrase: $key
		%pubring $file.pub
		%secring $file.sec
		%commit
		%echo done\n";

	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: key creation gpg process was killed: $buf");
		print STDERR "Error: key creation gpg process was killed: $buf\n";
		return(0);
	}

	$buf = $? >> 8;
	if ($buf != 0) {
		putlog('err',  "Error: key creation gpg process returned non-zero: $buf");
		print STDERR "Error: key creation gpg process returned non-zero: $buf\n";
		return(0);
	}

	return(0) unless save_keys($usr);

	return(1);
}

sub check_auth ($$) {
	my($usr) = $_[0];
	my($key) = $_[1];
	my($buf, $p, $ret, $file);

	putlog('debug', "Authenticating $usr against their keys...");

	$usr =~ /^(.*)$/;
	$file = md5_hex($1);

	unless (( -f "$file.sec") && ( -f "$file.pub")) {
		return(0) unless (fetch_keys($usr));
	}

	$buf = open($p, "|-");

	unless (defined($buf)) {
		$ret = $!;
		putlog('err',  "Error: unable to fork gpg for authenticaton: $ret");
		print STDERR "Error: unable to fork gpg for authenticaton: $ret!\n";
		return(0);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			$ret = $!;
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $ret");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $ret\n";
			exit(1);
		}       
		putlog('debug', join(" ", ('gpg1', '-q', '-a', '-o', '/dev/null',
			   '--no-secmem-warning',
			   '--no-tty', '--passphrase-fd', '0',
			   '--batch',
			   '--no-default-keyring',
			   '--keyring', "$file.pub",
			   '--secret-keyring', "$file.sec",
			   '-u', "$usr", '-s', "$file.sec")));
		{ exec {'gpg1'} ('gpg1', '-q', '-a', '-o', '/dev/null',
			   '--no-secmem-warning',
			   '--no-tty', '--passphrase-fd', '0',
			   '--batch',
			   '--no-default-keyring',
			   '--keyring', "$file.pub",
			   '--secret-keyring', "$file.sec",
			   '-u', "$usr", '-s', "$file.sec"); };
		putlog('err',  "Error: unable to exec gpg for authenticaton: $ret\n");
		exit(1);
	}

	print $p "$key\n";

	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: authenticating gpg process was killed: $buf");
		print STDERR "Error: authenticating gpg process was killed: $buf\n";
		return(0);
	}

	$buf = $? >> 8;

	if ($buf != 0) {
		putlog('err', "Error: gpg authentication failed.");
		return(0);
	}

	putlog('debug', "Authentication of $usr succesfull.");

	return(1);
}

sub show_user ($) {
	my($usr) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Fetching group membership for $usr from database...");

	$sql = "SELECT name FROM grpmbrs WHERE member = '$usr'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $usr . "'s groups: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $usr . "'s groups: " . $qry->errstr);
		return(0);
	}

	print STDOUT "$usr is a member of:\n";
	if ($qry->rows() < 1) {
		print STDOUT "\t<no groups>\n";
	} else {
		while ($res = $qry->fetchrow_hashref()) {
			print STDOUT "\t" . $res->{'name'} . "\n";
		}
	}

	putlog('debug', "Fetching explicit access for $usr from database...");

	$sql = "SELECT name FROM ascmbrs WHERE member = '$usr' AND flag != '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $usr . "'s access: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $usr . "'s access: " . $qry->errstr);
		return(0);
	}

	print STDOUT "$usr has explicit access to:\n";
	if ($qry->rows() < 1) {
		print STDOUT "\t<no entries>\n";
	} else {
		while ($res = $qry->fetchrow_hashref()) {
			print STDOUT "\t" . $res->{'name'} . "\n";
		}
	}

	putlog('debug', "Fetching explicit denies for $usr from database...");

	$sql = "SELECT name FROM ascmbrs WHERE member = '$usr' AND flag = '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $usr . "'s denies: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $usr . "'s denies: " . $qry->errstr);
		return(0);
	}

	print STDOUT "$usr is explicitly denied from:\n";
	if ($qry->rows() < 1) {
		print STDOUT "\t<no entries>\n";
	} else {
		while ($res = $qry->fetchrow_hashref()) {
			print STDOUT "\t" . $res->{'name'} . "\n";
		}
	}

	return(1);
}

sub list_users ($) {
	my($pat) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Fetching user list from database...");

	$sql = "SELECT name FROM users";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query for user listing:" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query for user listing: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) returned by query: %s", $qry->rows(), $sql);

	while ($res = $qry->fetchrow_hashref()) {
		next unless ($res->{'name'} =~ /$pat/);
		print STDOUT "" . $res->{'name'} . "\n";
	}

	putlog('debug', "User list succesfully fetched from database.");

	return(1);
}

sub check_group ($) {
	my($grp) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Checking existance of group $grp in the database...");

	$sql = "SELECT name FROM groups WHERE name = '$grp'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query for group check:" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query for group check: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) returned by query: %s", $qry->rows(), $sql);

	return(0) if ($qry->rows() < 1);

	putlog('debug', "Group $grp exists in the database.");

	return(1);
}

sub create_group ($) {
	my($grp) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Creating group $grp in the database...");

	$sql = "INSERT INTO groups VALUES ( '$grp' )";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query for group creation:" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query for group creation: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) affected by query: %s", $qry->rows(), $sql);

	putlog('debug', "Group $grp created in the database.");

	return(1);
}

sub add_to_group ($$) {
	my($grp) = $_[0];
	my($mbr) = $_[1];
	my($sql, $qry, $res);

	putlog('debug', "Adding $mbr to group $grp in the database...");

	# FIXME - do I care if they are in there already or not?
	$sql = "REPLACE INTO grpmbrs VALUES ( '$grp', '$mbr' )";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query for adding user to group :" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query for adding user to group: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) affected by query: %s", $qry->rows(), $sql);

	putlog('debug', "User $mbr added to $grp in the database.");

	return(1);
}

sub rem_from_group ($$) {
	my($grp) = $_[0];
	my($mbr) = $_[1];
	my($sql, $qry, $res);

	putlog('debug', "Removing $mbr from group $grp in the database...");

	$sql = "DELETE FROM grpmbrs where name = '$grp' AND member = '$mbr'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query for removing user from group :" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query for removing user from group: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) affected by query: %s", $qry->rows(), $sql);

	putlog('debug', "User $mbr removed from $grp in the database.");

	return(1);
}


sub delete_group ($) {
	my($grp) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Deleting group $grp from database...");

	$sql = "DELETE FROM groups WHERE name = '$grp'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to delete group $grp: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to delete group $grp: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) affected by query: %s", $qry->rows(), $sql);

	putlog('debug', "Keys for $grp successfully deleted from database.");

	return(1);
}


sub show_group ($) {
	my($grp) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Fetching membership of $grp from database...");

	$sql = "SELECT member FROM grpmbrs WHERE name = '$grp'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch membership of $grp: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch membership of $grp: " . $qry->errstr);
		return(0);
	}

	print STDOUT "$grp has members:\n";
	if ($qry->rows() < 1) {
		print STDOUT "\t<no members>\n";
	} else {
		while ($res = $qry->fetchrow_hashref()) {
			print STDOUT "\t" . $res->{'member'} . "\n";
		}
	}

	putlog('debug', "Fetching explicit access for $grp from database...");

	$sql = "SELECT name FROM ascmbrs WHERE member = '\@$grp' AND flag != '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $grp . "'s access: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $grp . "'s access: " . $qry->errstr);
		return(0);
	}

	print STDOUT "$grp has explicit access to:\n";
	if ($qry->rows() < 1) {
		print STDOUT "\t<no entries>\n";
	} else {
		while ($res = $qry->fetchrow_hashref()) {
			print STDOUT "\t" . $res->{'name'} . "\n";
		}
	}

	putlog('debug', "Fetching explicit denies for $grp from database...");

	$sql = "SELECT name FROM ascmbrs WHERE member = '\@$grp' AND flag = '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $grp . "'s denies: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $grp . "'s denies: " . $qry->errstr);
		return(0);
	}

	print STDOUT "$grp is explicitly denied from:\n";
	if ($qry->rows() < 1) {
		print STDOUT "\t<no entries>\n";
	} else {
		while ($res = $qry->fetchrow_hashref()) {
			print STDOUT "\t" . $res->{'name'} . "\n";
		}
	}

	return(1);
}

sub list_groups ($) {
	my($pat) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Fetching group list from database...");

	$sql = "SELECT name FROM groups";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query for group listing:" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query for group listing: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) returned by query: %s", $qry->rows(), $sql);

	while ($res = $qry->fetchrow_hashref()) {
		next unless ($res->{'name'} =~ /$pat/);
		print STDOUT "" . $res->{'name'} . "\n";
	}

	putlog('debug', "Group list succesfully fetched from database.");

	return(1);
}

sub add_to_asc ($$) {
	my($asc) = $_[0];
	my($mbr) = $_[1];
	my($sql, $qry, $res, $mod);

	putlog('debug', "Adding $mbr to key $asc in the database...");

	# FIXME - do I care if they are in there already or not?
	if ($mbr =~ s/^-//) {
		$mod = "-";
		$sql = "REPLACE INTO ascmbrs VALUES ( '$asc', '$mbr', '-' )";
	} else {
		$mod = "";
		$sql = "REPLACE INTO ascmbrs VALUES ( '$asc', '$mbr', '+' )";
	}

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query for adding member to key:" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query for adding member to key: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) affected by query: %s", $qry->rows(), $sql);

	putlog('debug', "Member $mod$mbr added to $asc in the database.");

	return(1);
}

sub rem_from_asc ($$) {
	my($asc) = $_[0];
	my($mbr) = $_[1];
	my($sql, $qry, $res);

	putlog('debug', "Removing $mbr from key $asc in the database...");

	$sql = "DELETE FROM ascmbrs where name = '$asc' AND member = '$mbr'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query for removing access from key :" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query for removing access from key: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) affected by query: %s", $qry->rows(), $sql);

	putlog('debug', "User $mbr removed from $asc in the database.");

	return(1);
}

sub show_key ($) {
	my($asc) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Fetching access list for $asc from database...");

	$sql = "SELECT member FROM ascmbrs WHERE name = '$asc' AND flag != '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $asc . "'s accesss: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $asc . "'s accesss: " . $qry->errstr);
		return(0);
	}

	print STDOUT "$asc is accessible to:\n";
	if ($qry->rows() < 1) {
		print STDOUT "\t<no entries>\n";
	} else {
		while ($res = $qry->fetchrow_hashref()) {
			print STDOUT "\t" . $res->{'member'} . "\n";
		}
	}

	putlog('debug', "Fetching deny list for $asc from database...");

	$sql = "SELECT member FROM ascmbrs WHERE name = '$asc' AND flag = '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $asc . "'s denies: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $asc . "'s denies: " . $qry->errstr);
		return(0);
	}

	print STDOUT "$asc is denied to:\n";
	if ($qry->rows() < 1) {
		print STDOUT "\t<no entries>\n";
	} else {
		while ($res = $qry->fetchrow_hashref()) {
			print STDOUT "\t" . $res->{'memeber'} . "\n";
		}
	}

	return(1);
}

sub check_asc ($) {
	my($asc) = $_[0];
	my($p, $buf, $out, $ret, $file);

	putlog('debug', "Checking validity of asc for $asc ...");

	$asc =~ /^(.*)$/;
	$file = md5_hex($1);
	
	unless ( -f "$file.asc") {
		return(0) unless (fetch_asc($asc, undef));
	}

	$buf = open($p, "-|");

	unless (defined($buf)) {
		$ret = $!;
		putlog('err',  "Error: unable to fork gpg for asc verification: $ret");
		print STDERR "Error: unable to fork gpg for asc verification: $ret\n";
		return(0);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDIN) && open(STDIN, "</dev/null"))) {
			$ret = $!;
			putlog('err',  "Error: unable to map gpg's stdin to /dev/null: $ret");
			print STDERR "Error: unable to map gpg's stdin to /dev/null: $ret\n";
			bail(1);
		}       
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			$ret = $!;
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $ret");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $ret\n";
			bail(1);
		}       
		putlog('debug', "exec: " . join(" ", 'gpg1', '--no-secmem-warning',
                        '--list-only', '--no-default-keyring', '--logger-fd', '1',
                        '--keyring', '/dev/null', '--secret-keyring', '/dev/null',
                        "$file.asc"));
		{ exec {'gpg1'} ('gpg1', '--no-secmem-warning',
                        '--list-only', '--no-default-keyring', '--logger-fd', '1',
                        '--keyring', '/dev/null', '--secret-keyring', '/dev/null',
                        "$file.asc"); }
		$ret = $!;
		putlog('err',  "Error: unable to exec gpg for asc verification: $ret");
		print STDERR "Error: unable to exec gpg for asc verification: $ret\n";
		exit(1);
	}

	$out = "";	
	while (<$p>) {
		putlog('debug', "$_");
		chomp();
		next unless (/^gpg: encrypted with/);
		$out .= $_;
	}

	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: asc verifing gpg process was killed: $buf");
		print STDERR "Error: asc verifing gpg process was killed: $buf\n";
		return(0);
	}

	if ($out eq "") {
		putlog('err', "Error asc verification failed.");
		return(0);
	}

	putlog('debug', "Validation of asc for $asc succesfull.");

	return(1);
}

sub encrypt_asc ($$$$) {
	my($asc) = $_[0];
	my($user) = $_[1];
	my($pass) = $_[2];
	my($key) = $_[3];
	my($p, $file, $buf, $ret);
	my(@keys, @files);

	putlog('debug', "Encrypting asc file for $asc ...");

	if ((defined($pass) && defined($key))) {
		putlog('err', sprintf "Error: internal error at %d. This is a bug!", __LINE__);
		printf STDERR "Error: internal error at %d. This is a bug!\n", __LINE__;
		return(0);
	}

	$asc =~ /^(.*)$/;
	$file = md5_hex($1);

	if (($key) && ( -f "$file.asc")) {
		unlink("$file.asc");
	}
 
	if (($pass) && ( ! -f "$file.asc")) {
		fetch_asc($asc, undef);
	}

	if ( -f "$file.asc") {
		putlog('debug', "Encrypting asc file for $asc exists so decrypting...");
		unless ($key = decrypt_asc($user, $pass, $asc)) {
			return(0);
		}
	}

	return(0) unless (@keys = import_keys($asc));
	foreach (@keys) {
		push(@files, "-r", "$_@");
	}

	$buf = open($p, "|-");

	unless (defined($buf)) {
		$ret = $!;
		putlog('err',  "Error: unable to fork gpg for encryption: $ret");
		print STDERR "Error: unable to fork gpg for encryption: $ret\n";
		return(0);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			$ret = $!;
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $ret");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $ret\n";
			exit(1);
		}       
		putlog('debug', join(" ", ('gpg1', '-a', '--yes', '--encrypt', '--always-trust', 
			'--no-secmem-warning',
			@files, '-o', "$file.asc")));
		{ exec {'gpg1'} ('gpg1', '-a', '--yes', '--encrypt', '--always-trust', 
			'--no-secmem-warning',
			@files, '-o', "$file.asc"); };
		$ret = $!;
		putlog('err',  "Error: unable to exec gpg for encryption: $ret");
		print STDERR "Error: unable to exec gpg for encryption: $ret\n";
		exit(1);
	}

	print $p "$key\n";
	
	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: encrypting gpg process was killed: $buf");
		print STDERR "Error: encrypting gpg process was killed: $buf\n";
		return(0);
	}

	$buf = $? >> 8;
	if ($buf != 0) {
		putlog('err',  "Error: encrypting gpg process returned non-zero: $buf");
		print STDERR "Error: encrypting gpg process returned non-zero: $buf\n";
		return(0);
	}

	return(0) unless save_asc($asc);

	return(1);
}

sub decrypt_asc ($$$) {
	my($user) = $_[0];
	my($pass) = $_[1];
	my($asc) = $_[2];
	my($buf, $out, $ret);
	my($userfile, $ascfile);
	my($p, $r, $w);
	local($/) = undef;

	$asc =~ /^(.*)$/;
	$ascfile = md5_hex($1);

	$user =~ /^(.*)$/;
	$userfile = md5_hex($user = $1);

	putlog('debug', "Decrypting asc for $asc from $ascfile.asc ...");

	unless (pipe($r, $w)) {
		$ret = $!;
		putlog('err',  "Error: unable to create password channel: $ret");
		print STDERR "Error: unable to create password channel: $ret\n";
		return(undef);
	}
	unless (fcntl($r, F_GETFD, $buf)) {
		$ret = $!;
		putlog('err',  "Error: unable to F_GETFD on password channel: $ret");
		print STDERR "Error: unable to F_GETFD on password channel: $ret\n";
	}
	$buf &= FD_CLOEXEC;
	unless (fcntl($r, F_SETFD, $buf)) {
		$ret = $!;
		putlog('err',  "Error: unable to F_SETFD on password channel: $ret");
		print STDERR "Error: unable to F_SETFD on password channel: $ret\n";
	}

	$buf = open($p, "-|");

	unless (defined($buf)) {
		$ret = $!;
		putlog('err',  "Error: unable to fork gpg for decryption: $ret");
		print STDERR "Error: unable to fork gpg for decryption: $ret\n";
		return(undef);
	} elsif ($buf == 0) {
		unless (($DEBUG) || (close(STDIN) && open(STDIN, "</dev/null"))) {
			$ret = $!;
			putlog('err',  "Error: unable to map gpg's stdin to /dev/null: $ret");
			print STDERR "Error: unable to map gpg's stdin to /dev/null: $ret\n";
			exit(1);
		}       
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			$ret = $!;
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $ret");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $ret\n";
			exit(1);
		}       
		putlog('debug', join(" ", ('gpg1', '--decrypt', 
			'--no-tty', '--passphrase-fd', fileno($r), '--batch',
			'--no-secmem-warning', '--no-default-keyring',
			'--secret-keyring', "$userfile.sec",
			'--keyring', "$userfile.pub", '-u', "$user",
			"$ascfile.asc")));
		{ exec {'gpg1'} ('gpg1', '--decrypt', 
			'--no-tty', '--passphrase-fd', fileno($r), '--batch',
			'--no-secmem-warning', '--no-default-keyring',
			'--secret-keyring', "$userfile.sec",
			'--keyring', "$userfile.pub", '-u', "$user",
			"$ascfile.asc"); };
		$ret = $!;
		putlog('err',  "Error: unable to exec gpg for decryption: $ret");
		print STDERR "Error: unable to exec gpg for decryption: $ret\n";
		exit(1);
	}

	print $w "$pass\n";
	close($w);

	$out = <$p>;
	$out =~ s/\n+$/\n/s;

	close($p);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: decrypting gpg process was killed: $buf");
		print STDERR "Error: decrypting gpg process was killed: $buf\n";
		return(undef);
	}

	$buf = $? >> 8;
	return(undef) if ($buf != 0);

	putlog('debug', "Succesfully decrypted asc for $asc from $ascfile.asc");

	return($out);
}

sub import_keys ($) {
	my($asc) = $_[0];
	my($sql, $qry, $res, $ret, $buf);
	my(%mbrs, $mbr, @files);

	# get all the allowed groups and users
	# turn all the allowed groups into users
	# get all the denie/pd groups and users
	# turn all the denied groups into users
	# substract denied users from allowed users
	# add 'root' to allowed users
	# fetch keys for all allowed users
	# import fetched kets into the keyring

	putlog('debug', "Import gpg keys for users with access to $asc ...");
	
	putlog('debug', "Fetching allowed members for $asc from database...");

	$sql = "SELECT member FROM ascmbrs WHERE name = '$asc' && flag != '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query of allowed members for $asc:" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query of allowed members for $asc:" . $qry->errstr);
		return(0);
	}

	while ($res = $qry->fetchrow_hashref()) {
		if ($res->{'member'} =~ s/^@//) {
			putlog('debug', "Group " . $res->{'member'} . " found with access to $asc ...");
			foreach $mbr (get_group_mbrs($res->{'member'})) {
				putlog('debug', "Member $mbr of group " . $res->{'member'} . " has access to $asc ...");
				$mbrs{$mbr} = 1;
			}
		} else {
			putlog('debug', "User " . $res->{'member'} . " found with access to $asc ...");
			$mbrs{$res->{'member'}} = 1;
		}
	}

	putlog('debug', "Fetching denied members for $asc from database...");

	$sql = "SELECT member FROM ascmbrs WHERE name = '$asc' && flag = '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query of denied members for $asc:" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query of denied members for $asc:" . $qry->errstr);
		return(0);
	}

	while ($res = $qry->fetchrow_hashref()) {
		if ($res->{'member'} =~ s/^@//) {
			putlog('debug', "Group " . $res->{'member'} . " found is denied from $asc ...");
			foreach $mbr (get_group_mbrs($res->{'member'})) {
				putlog('debug', "Member $mbr of group " . $res->{'member'} . " is denied from $asc ...");
				delete($mbrs{$mbr});
			}
		} else {
			delete($mbrs{$res->{'member'}});
		}
	}

	$mbrs{'root'} = 1;

	putlog('debug', sprintf "List of %d users with access to $asc found", scalar(keys %mbrs));
		
	foreach (keys %mbrs) {
		push(@files, md5_hex($_) . ".pub") if fetch_keys($_);
	}

	unless (( ! -e 'pubring.gpg') || unlink('pubring.gpg')) {
		$ret = $!;
		putlog('err',  "Error: unable to unlink existing pubring.gpg: $ret");
		print STDERR "Error: unable to unlink existing pubring.gpg: $ret\n";
		return(());
	}
	unless (( ! -e 'secring.gpg') || unlink('secring.gpg')) {
		$ret = $!;
		putlog('err',  "Error: unable to unlink existing secring.gpg: $ret");
		print STDERR "Error: unable to unlink existing secring.gpg: $ret\n";
		return(());
	}

	$buf = fork();

	unless (defined($buf)) {
		$ret = $!;
		putlog('err',  "Error: unable to fork gpg for import: $ret");
		print STDERR "Error: unable to fork gpg for import: $ret\n";
		return(());
	} elsif ($buf == 0) {
		close(STDIN) && open(STDIN, "</dev/null");
		unless (($DEBUG) || (close(STDERR) && open(STDERR, ">/dev/null"))) {
			$ret = $!;
			putlog('err',  "Error: unable to map gpg's stderr to /dev/null: $ret");
			print STDERR "Error: unable to map gpg's stderr to /dev/null: $ret\n";
			exit(1);
		}       
		putlog('debug', join(" ", ('gpg1', '--fast-import', '--no-secmem-warning', @files)));
		{ exec {'gpg1'} ('gpg1', '--fast-import', '--no-secmem-warning', @files); };
		$ret = $!;
		putlog('err',  "Error: unable to exec gpg for import: $ret");
		print STDERR "Error: unable to exec gpg for import: $ret\n";
		exit(1);
	}

	$buf = waitpid($buf, 0);

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: importing gpg process was killed: $buf");
		print STDERR "Error: importing gpg process was killed: $buf\n";
		return(());
	}

	$buf = $? >> 8;
	if ($buf != 0) {
		putlog('err',  "Error: importing process returned non-zero: $buf");
		print STDERR "Error: importing gpg process returned non-zero: $buf\n";
		return(());
	}

	return(keys %mbrs);
}

sub get_updates ($$) {
	my($asc) = $_[0];
	my($cnt) = $_[1];
	my($sql, $qry, $res, @upds);

	$cnt = 1 unless ($cnt);

	putlog('debug', "Fetching update history for $asc from database: $cnt");

	$sql = "SELECT updated FROM ascs WHERE name = '$asc' ORDER BY updated DESC LIMIT $cnt";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $asc . "'s ascs: " . $DBHAND->errstr);
		return(());
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $asc . "'s ascs: " . $qry->errstr);
		return(());
	}

	putlog('debug', sprintf "%d row(s) returned by query: %s", $qry->rows(), $sql);

	while ($res = $qry->fetchrow_hashref()) {
		push(@upds, $res->{'updated'});
	}

	return(@upds);
}

sub check_rate ($) {
	my($asc) = $_[0];
	my($cnt, $sec, $sql, $qry, $res);

	unless (defined($MAXRATE)) {
		return(1);
	}

	unless ($MAXRATE =~ /^(\d+):(\d+)$/) {
		putlog('err', "Error: an invalid maxrate has been specified: $MAXRATE");
		putlog STDERR "Error: an invalid maxrate has been specified: $MAXRATE\n";
		return(0);
	}

	$cnt = $1;
	$sec = time() - $2;

	putlog('debug', "Fetching update history for $asc from database: $cnt");

	$sql = "SELECT unix_timestamp(updated) FROM ascs WHERE name = '$asc' ORDER BY updated DESC LIMIT $cnt";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $asc . "'s ascs: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $asc . "'s ascs: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) returned by query: %s", $qry->rows(), $sql);

	# there are not enough changes to worry about, we're fine
	return (1) if ($qry->rows() < $cnt);

	while ($res = $qry->fetchrow_hashref()) {
		# our count included one older then $sec, we're fine
		return (1) if ($res->{'unix_timestamp(updated)'} < $sec);
	}

	# found enough entires, but they're all too new, too fast
	return(0);
}

sub fetch_asc ($$) {
	my($asc) = $_[0];
	my($upd) = $_[1];
	my($sql, $qry, $res);
	my($f, $file);

	$asc =~ /^(.*)$/;
	$file = md5_hex($1);

	if ($upd) {
		putlog('debug', "Fetching $upd ascs for $asc from database to $file.asc");
	} else {
		putlog('debug', "Fetching most recent ascs for $asc from database to $file.asc");
	}

	if ($upd) {
		$sql = "SELECT * FROM ascs WHERE name = '$asc' AND updated = '$upd'";
	} else {
		$sql = "SELECT * FROM ascs WHERE name = '$asc' ORDER BY updated DESC LIMIT 1";
	}

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $asc . "'s ascs: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $asc . "'s ascs: " . $qry->errstr);
		return(0);
	}

	$res = $qry->fetchrow_hashref();

	unless (defined($res)) {
		putlog('notice', "No ascs for $asc are present in the database.");
		return(0);
	}

	unless ($res->{'name'} eq $asc) {
		# WTF? How did this happen!?? 
		putlog('err', "The query for " . $asc . "'s ascs has returned " . $res->{'name'} . "'s ascs.");
		return(0);
	}

	unless (open($f, ">$file.asc")) {
		putlog('err', "Unable to open asc file for writing: $file.asc: $!");
		return(0);
	}

	unless (print $f $res->{'pass'}) {
		putlog('err', "Unable to write the asc to file: $file.asc: $!");
		return(0);
	}

	unless (close($f)) {
		putlog('err', "Unable to save the asc file after writing: $file.asc: $!");
		return(0);
	}

	putlog('debug', "asc for $asc successfully fetched to $file.asc");

	return(1);
}

sub save_asc ($) {
	my($asc) = $_[0];
	my($sql, $qry, $res, $pass);
	my($f, $file);

	putlog('debug', "Saving ascs for $asc in database...");

	$asc =~ /^(.*)$/;
	$file = md5_hex($1);

	unless (open($f, "<$file.asc")) {
		putlog('err', "Unable to open asc file for reading: $file.asc: $!");
		return(0);
	}

	$pass = join("",  (<$f>));

	close($f);

	$sql = "INSERT INTO ascs VALUES ( ?, ?, NULL)";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to save " . $asc . "'s asc: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute($asc, $pass)) {
		putlog('err', "Unable to execute SQL query to save " . $asc . "'s asc: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) affected by query: %s", $qry->rows(), $sql);

	putlog('debug', "asc for $asc successfully saved database:" . $qry->errstr);

	return(1);
}

sub delete_asc ($) {
	my($asc) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Deleting asc $asc from database...");

	$sql = "DELETE ascs, ascmbrs FROM ascs LEFT JOIN ascmbrs ON ascs.name = ascmbrs.name WHERE ascs.name = '$asc'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to delete asc $asc: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to delete asc $asc: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) affected by query: %s", $qry->rows(), $sql);

	putlog('debug', "Keys for $asc successfully deleted from database.");

	return(1);
}

sub list_keys ($) {
	my($pat) = $_[0];
	my($sql, $qry, $res, %seen);

	putlog('debug', "Fetching key list from database...");

	$sql = "SELECT name FROM ascs";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query for key listing:" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query for key listing: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) returned by query: %s", $qry->rows(), $sql);

	while ($res = $qry->fetchrow_hashref()) {
		next unless ($res->{'name'} =~ /$pat/);
		next if ($seen{$res->{'name'}});
		next unless (check_asc($res->{'name'}));
		print STDOUT "" . $res->{'name'} . "\n";
		$seen{$res->{'name'}} = 1;
	}

	putlog('debug', "Key list succesfully fetched from database.");

	return(1);
}

sub get_user_access ($) {
	my($usr) = $_[0];
	my($sql, $qry, $res);
	my(%keys, @grps, $grp);

	putlog('debug', "Fetching key access list for $usr from database...");

	putlog('debug', "Fetching group membership for $usr from database...");

	$sql = "SELECT name FROM grpmbrs WHERE member = '$usr'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $usr . "'s groups: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $usr . "'s groups: " . $qry->errstr);
		return(0);
	}

	while ($res = $qry->fetchrow_hashref()) {
		push(@grps, $res->{'name'});
	}

	putlog('debug', sprintf "List of %d groups for $usr fetched.", scalar(@grps));

	foreach $grp (@grps) {
		foreach (get_group_access($grp)) {
			$keys{$_} = 1;
		}
	}

	putlog('debug', "Fetching key access list for $usr from database...");

	$sql = "SELECT name FROM ascmbrs WHERE member = '$usr' AND flag != '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $usr . "'s access: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $usr . "'s access: " . $qry->errstr);
		return(0);
	}

	while ($res = $qry->fetchrow_hashref()) {
		$keys{$res->{'name'}} = 1;
	}


	foreach $grp (@grps) {
		foreach (get_group_denies($grp)) {
			delete($keys{$_});
		}
	}

	return(keys(%keys));
}

sub get_group_mbrs ($) {
	my($grp) = $_[0];
	my($sql, $qry, $res);
	my(@mbrs);

	putlog('debug', "Fetching member list for $grp from database...");

	$sql = "SELECT member FROM grpmbrs WHERE name = '$grp'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $grp . "'s members: " . $DBHAND->errstr);
		return(undef);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $grp . "'s members: " . $qry->errstr);
		return(undef);
	}

	while ($res = $qry->fetchrow_hashref()) {
		push(@mbrs, $res->{'member'});
	}

	putlog('debug', sprintf "List of %d members for $grp fetched.", scalar(@mbrs));

	return(@mbrs);
}

sub get_group_access ($) {
	my($grp) = $_[0];
	my($sql, $qry, $res);
	my(%keys);

	putlog('debug', "Fetching key access list for $grp from database...");

	$sql = "SELECT name FROM ascmbrs WHERE member = '\@$grp' AND flag != '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $grp . "'s access: " . $DBHAND->errstr);
		return(undef);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $grp . "'s access: " . $qry->errstr);
		return(undef);
	}

	while ($res = $qry->fetchrow_hashref()) {
		$keys{$res->{'name'}} = 1;
	}

	putlog('debug', sprintf "List of %d allowed keys for $grp fetched.", scalar(keys(%keys)));

	return(keys(%keys));
}

sub get_group_denies ($) {
	my($grp) = $_[0];
	my($sql, $qry, $res);
	my(%keys);

	putlog('debug', "Fetching key deny list for $grp from database...");

	$sql = "SELECT name FROM ascmbrs WHERE member = '\@$grp' AND flag = '-'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $grp . "'s denies: " . $DBHAND->errstr);
		return(undef);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $grp . "'s denies: " . $qry->errstr);
		return(undef);
	}

	while ($res = $qry->fetchrow_hashref()) {
		$keys{$res->{'name'}} = 1;
	}

	putlog('debug', sprintf "List of %d denied key for $grp fetched.", scalar(keys(%keys)));

	return(keys(%keys));
}

sub cleanup_user ($) {
	my($usr) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Deleting references to $usr from from database...");

	$sql = "DELETE FROM ascmbrs WHERE member = '$usr'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $usr . "'s denies: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $usr . "'s denies: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) deleted  from ascmbrs: %s", $qry->rows(), $sql);

	$sql = "DELETE FROM grpmbrs WHERE member = '$usr'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $usr . "'s denies: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $usr . "'s denies: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) deleted  from grpmbrs: %s", $qry->rows(), $sql);


	return(1);
}

sub cleanup_group ($) {
	my($grp) = $_[0];
	my($sql, $qry, $res);

	putlog('debug', "Deleting references to $grp from the database...");

	$sql = "DELETE FROM ascmbrs WHERE member = '$grp'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query to fetch " . $grp . "'s denies: " . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query to fetch " . $grp . "'s denies: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) deleted  from ascmbrs: %s", $qry->rows(), $sql);

	$sql = "DELETE FROM grpmbrs WHERE name = '$grp'";

	unless ($qry = $DBHAND->prepare($sql)) {
		putlog('err', "Unable to prepare SQL query for group clearing:" . $DBHAND->errstr);
		return(0);
	}

	unless ($qry->execute()) {
		putlog('err', "Unable to execute SQL query for group clearing: " . $qry->errstr);
		return(0);
	}

	putlog('debug', sprintf "%d row(s) deleted  from grpmbrs: %s", $qry->rows(), $sql);

	return(1);
}

sub change_key ($) {
        my($usr) = $_[0];
	my($buf, $file, $ret);

	putlog('debug', "Changing password on keys for $usr ...");

	$usr =~ /^(.*)$/;
	$file = md5_hex($1);
	
	unless (( -f "$file.sec") && ( -f "$file.pub")) {
		return(0) unless (fetch_keys($usr));
	}

	putlog('debug', join(" ", ('gpg1', '-q', 
		'--no-secmem-warning',
		'--no-default-keyring',
		'--keyring', "$file.pub",
		'--secret-keyring', "$file.sec",
		'--edit-key', $usr, 'passwd', 'save', 'quit')));
	system {'gpg1'} ('gpg1', '-v',
		'--no-secmem-warning',
		'--no-default-keyring',
		'--keyring', "$file.pub",
		'--secret-keyring', "$file.sec", 
		'--edit-key', $usr, 'passwd', 'save', 'quit');

	$buf = $? & 127;
	if ($buf != 0) {
		putlog('err',  "Error: pass change gpg process was killed: $buf");
		print STDERR "Error: pass change gpg process was killed: $buf\n";
		return(0);
	}

	$buf = $? >> 8;
	if ($buf != 0) {
		putlog('err',  "Error: pass change process returned non-zero: $buf");
		print STDERR "Error: pass change gpg process returned non-zero: $buf\n";
		return(0);
	}

	return(0) unless save_keys($usr);

	return(1);
}
